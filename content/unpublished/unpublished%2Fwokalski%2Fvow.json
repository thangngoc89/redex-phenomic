{"type":"unpublished","id":"unpublished/wokalski/vow","name":"wokalski/vow","version":"0.0.2","description":"Almost sound Promises for Bucklescript","license":"MIT","keywords":["promise","bucklescript","reason"],"readme":"# Vow\n\n`Vow` is a tiny library which allows you to handle promises more safely in your Bucklescript application.\n\nA `Vow` can be either `handled` and `unhandled`. All promises of type `vow 'a handled` make sure that you handled Promise rejections. Thanks to that you will avoid the Uncaught promise error.\n\n## Side effects\n\nAfter series of operations you usually want to \"consume\" a promise. `Vow.sideEffect` should be used for that.\n\nIt only accepts promises which are properly handled.\n\n## Unwrapping\n\nYou can unwrap a handled promise using `Vow.unwrap`.\n\n## Nesting vows\n\n`Js.Promise.t` is unsafe when you nest promises. i.e. `Js.Promise.t (Js.Promise.t 'a)` is unsound. In the runtime it's `Js.Promise.t`.\n\nThis is resolved with `vow`s. If you nest `vow`s they behave as expected.\n\nHowever if you put a `Js.Promise.t` inside a `vow` (which are boxed `Js.Promise.t` under the scenes) you're gonna get a `vow` of the following type:\n\n```reason\n/* in Reason syntax */\n\nvow (Js.Promise.t 'a) 'status\n```\nHowever, under the scenes it'll really be\n\n```reason\n\nvow 'a 'status\n```\n\nTherefore `vow` is not sound.\n\n## Binding\n\nIn order to use vows you have to bind to your existing APIs using `Vow.wrap`/`Vow.unsafeWrap`.\n\nIf you `unsafeWrap` a promise which does throw your code will be unsound.\n\n## Example\n\nLet's see a real world example of vows with some comments:\n\n```reason\nlet login _: Vow.Result.t authenticationState error Vow.handled =>\n  /* Returns a handled Vow.Result.t */\n  Login.logIn () |>\n  /* Validates the returned value. Since the vow is handled we don't need to catch*/\n  Vow.Result.map (\n    fun x =>\n      if x##isCancelled {\n        Vow.Result.fail LoginRequestCancelled\n      } else {\n        Vow.Result.return ()\n      }\n  ) |>\n  /* Another handled Vow.Result.t */\n  Vow.Result.map Login.getCurrentAccessToken () |>\n  Vow.Result.map (\n    fun x => {\n      let token = x##accessToken;\n      /* This returns an unhandled Vow.Result.t.\n       * Note that the 'error types have to match\n       * Because after one error the subsequent operations\n       * Are not performed.\n       */\n      Queries.login ::token\n    }\n  ) |>\n  /* Ooops, the `Queries.login` might reject.\n   * We are forced to handle it in the compile time.\n   */\n  Vow.Result.onError (fun _ => Vow.Result.fail GraphQlSignInError) |>\n  Vow.Result.map (\n    fun x =>\n      switch x {\n      | Authenticated {token, userId} =>\n        /* The promise we wrap is never rejected */\n        Vow.unsafeWrap\n          KeyChain.(\n            Js.Promise.all2 (\n              setGenericPassword username::\"userId\" password::userId service::\"userId\",\n              setGenericPassword username::\"token\" password::token service::\"token\"\n            )\n          ) |>\n        Vow.map (fun _ => Vow.Result.return x)\n      | _ => Vow.Result.return x\n      }\n  );\n```\n\n## Author\n\n[@wokalski](http://twitter.com/wokalski) \n\n","analyzed":"2017-12-24T16:47:08.129Z","updated":"2017-12-24T16:47:08.129Z","stars":31,"score":0,"quality":0,"popularity":0,"maintenance":0,"homepageUrl":"https://github.com/wokalski/vow#readme","repositoryUrl":"https://github.com/wokalski/vow","npmUrl":null,"issuesUrl":"https://github.com/wokalski/vow/issues","docsUrl":null}